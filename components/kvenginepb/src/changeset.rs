// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `changeset.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct ChangeSet {
    // message fields
    pub shard_id: u64,
    pub shard_ver: u64,
    pub compaction: ::protobuf::SingularPtrField<Compaction>,
    pub flush: ::protobuf::SingularPtrField<Flush>,
    pub snapshot: ::protobuf::SingularPtrField<Snapshot>,
    pub stage: SplitStage,
    pub pre_split: ::protobuf::SingularPtrField<PreSplit>,
    pub split_files: ::protobuf::SingularPtrField<SplitFiles>,
    pub split: ::protobuf::SingularPtrField<Split>,
    pub shard_delete: bool,
    pub sequence: u64,
    pub next_mem_table_size: i64,
    pub parent: ::protobuf::SingularPtrField<ChangeSet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeSet {
    fn default() -> &'a ChangeSet {
        <ChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    // uint64 shardID = 1;


    pub fn get_shard_id(&self) -> u64 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u64) {
        self.shard_id = v;
    }

    // uint64 shardVer = 2;


    pub fn get_shard_ver(&self) -> u64 {
        self.shard_ver
    }
    pub fn clear_shard_ver(&mut self) {
        self.shard_ver = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_ver(&mut self, v: u64) {
        self.shard_ver = v;
    }

    // .enginepb.Compaction compaction = 4;


    pub fn get_compaction(&self) -> &Compaction {
        self.compaction.as_ref().unwrap_or_else(|| Compaction::default_instance())
    }
    pub fn clear_compaction(&mut self) {
        self.compaction.clear();
    }

    pub fn has_compaction(&self) -> bool {
        self.compaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compaction(&mut self, v: Compaction) {
        self.compaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compaction(&mut self) -> &mut Compaction {
        if self.compaction.is_none() {
            self.compaction.set_default();
        }
        self.compaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_compaction(&mut self) -> Compaction {
        self.compaction.take().unwrap_or_else(|| Compaction::new())
    }

    // .enginepb.Flush flush = 5;


    pub fn get_flush(&self) -> &Flush {
        self.flush.as_ref().unwrap_or_else(|| Flush::default_instance())
    }
    pub fn clear_flush(&mut self) {
        self.flush.clear();
    }

    pub fn has_flush(&self) -> bool {
        self.flush.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: Flush) {
        self.flush = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flush(&mut self) -> &mut Flush {
        if self.flush.is_none() {
            self.flush.set_default();
        }
        self.flush.as_mut().unwrap()
    }

    // Take field
    pub fn take_flush(&mut self) -> Flush {
        self.flush.take().unwrap_or_else(|| Flush::new())
    }

    // .enginepb.Snapshot snapshot = 6;


    pub fn get_snapshot(&self) -> &Snapshot {
        self.snapshot.as_ref().unwrap_or_else(|| Snapshot::default_instance())
    }
    pub fn clear_snapshot(&mut self) {
        self.snapshot.clear();
    }

    pub fn has_snapshot(&self) -> bool {
        self.snapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: Snapshot) {
        self.snapshot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshot(&mut self) -> &mut Snapshot {
        if self.snapshot.is_none() {
            self.snapshot.set_default();
        }
        self.snapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshot(&mut self) -> Snapshot {
        self.snapshot.take().unwrap_or_else(|| Snapshot::new())
    }

    // .enginepb.SplitStage stage = 7;


    pub fn get_stage(&self) -> SplitStage {
        self.stage
    }
    pub fn clear_stage(&mut self) {
        self.stage = SplitStage::Initial;
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: SplitStage) {
        self.stage = v;
    }

    // .enginepb.PreSplit preSplit = 8;


    pub fn get_pre_split(&self) -> &PreSplit {
        self.pre_split.as_ref().unwrap_or_else(|| PreSplit::default_instance())
    }
    pub fn clear_pre_split(&mut self) {
        self.pre_split.clear();
    }

    pub fn has_pre_split(&self) -> bool {
        self.pre_split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_split(&mut self, v: PreSplit) {
        self.pre_split = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_split(&mut self) -> &mut PreSplit {
        if self.pre_split.is_none() {
            self.pre_split.set_default();
        }
        self.pre_split.as_mut().unwrap()
    }

    // Take field
    pub fn take_pre_split(&mut self) -> PreSplit {
        self.pre_split.take().unwrap_or_else(|| PreSplit::new())
    }

    // .enginepb.SplitFiles splitFiles = 9;


    pub fn get_split_files(&self) -> &SplitFiles {
        self.split_files.as_ref().unwrap_or_else(|| SplitFiles::default_instance())
    }
    pub fn clear_split_files(&mut self) {
        self.split_files.clear();
    }

    pub fn has_split_files(&self) -> bool {
        self.split_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_files(&mut self, v: SplitFiles) {
        self.split_files = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_split_files(&mut self) -> &mut SplitFiles {
        if self.split_files.is_none() {
            self.split_files.set_default();
        }
        self.split_files.as_mut().unwrap()
    }

    // Take field
    pub fn take_split_files(&mut self) -> SplitFiles {
        self.split_files.take().unwrap_or_else(|| SplitFiles::new())
    }

    // .enginepb.Split split = 10;


    pub fn get_split(&self) -> &Split {
        self.split.as_ref().unwrap_or_else(|| Split::default_instance())
    }
    pub fn clear_split(&mut self) {
        self.split.clear();
    }

    pub fn has_split(&self) -> bool {
        self.split.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split(&mut self, v: Split) {
        self.split = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_split(&mut self) -> &mut Split {
        if self.split.is_none() {
            self.split.set_default();
        }
        self.split.as_mut().unwrap()
    }

    // Take field
    pub fn take_split(&mut self) -> Split {
        self.split.take().unwrap_or_else(|| Split::new())
    }

    // bool shardDelete = 11;


    pub fn get_shard_delete(&self) -> bool {
        self.shard_delete
    }
    pub fn clear_shard_delete(&mut self) {
        self.shard_delete = false;
    }

    // Param is passed by value, moved
    pub fn set_shard_delete(&mut self, v: bool) {
        self.shard_delete = v;
    }

    // uint64 sequence = 12;


    pub fn get_sequence(&self) -> u64 {
        self.sequence
    }
    pub fn clear_sequence(&mut self) {
        self.sequence = 0;
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u64) {
        self.sequence = v;
    }

    // int64 nextMemTableSize = 13;


    pub fn get_next_mem_table_size(&self) -> i64 {
        self.next_mem_table_size
    }
    pub fn clear_next_mem_table_size(&mut self) {
        self.next_mem_table_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_mem_table_size(&mut self, v: i64) {
        self.next_mem_table_size = v;
    }

    // .enginepb.ChangeSet parent = 14;


    pub fn get_parent(&self) -> &ChangeSet {
        self.parent.as_ref().unwrap_or_else(|| ChangeSet::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ChangeSet) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ChangeSet {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> ChangeSet {
        self.parent.take().unwrap_or_else(|| ChangeSet::new())
    }
}

impl ::protobuf::Message for ChangeSet {
    fn is_initialized(&self) -> bool {
        for v in &self.compaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flush {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.snapshot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pre_split {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.split_files {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.split {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shard_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shard_ver = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compaction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flush)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshot)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stage, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pre_split)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.split_files)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.split)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shard_delete = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_mem_table_size = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shard_ver != 0 {
            my_size += ::protobuf::rt::value_size(2, self.shard_ver, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.compaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flush.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stage != SplitStage::Initial {
            my_size += ::protobuf::rt::enum_size(7, self.stage);
        }
        if let Some(ref v) = self.pre_split.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.split_files.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.split.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.shard_delete != false {
            my_size += 2;
        }
        if self.sequence != 0 {
            my_size += ::protobuf::rt::value_size(12, self.sequence, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_mem_table_size != 0 {
            my_size += ::protobuf::rt::value_size(13, self.next_mem_table_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint64(1, self.shard_id)?;
        }
        if self.shard_ver != 0 {
            os.write_uint64(2, self.shard_ver)?;
        }
        if let Some(ref v) = self.compaction.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flush.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.snapshot.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stage != SplitStage::Initial {
            os.write_enum(7, self.stage.value())?;
        }
        if let Some(ref v) = self.pre_split.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.split_files.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.split.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.shard_delete != false {
            os.write_bool(11, self.shard_delete)?;
        }
        if self.sequence != 0 {
            os.write_uint64(12, self.sequence)?;
        }
        if self.next_mem_table_size != 0 {
            os.write_int64(13, self.next_mem_table_size)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shardID",
                    |m: &ChangeSet| { &m.shard_id },
                    |m: &mut ChangeSet| { &mut m.shard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shardVer",
                    |m: &ChangeSet| { &m.shard_ver },
                    |m: &mut ChangeSet| { &mut m.shard_ver },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Compaction>>(
                    "compaction",
                    |m: &ChangeSet| { &m.compaction },
                    |m: &mut ChangeSet| { &mut m.compaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Flush>>(
                    "flush",
                    |m: &ChangeSet| { &m.flush },
                    |m: &mut ChangeSet| { &mut m.flush },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Snapshot>>(
                    "snapshot",
                    |m: &ChangeSet| { &m.snapshot },
                    |m: &mut ChangeSet| { &mut m.snapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SplitStage>>(
                    "stage",
                    |m: &ChangeSet| { &m.stage },
                    |m: &mut ChangeSet| { &mut m.stage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreSplit>>(
                    "preSplit",
                    |m: &ChangeSet| { &m.pre_split },
                    |m: &mut ChangeSet| { &mut m.pre_split },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SplitFiles>>(
                    "splitFiles",
                    |m: &ChangeSet| { &m.split_files },
                    |m: &mut ChangeSet| { &mut m.split_files },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Split>>(
                    "split",
                    |m: &ChangeSet| { &m.split },
                    |m: &mut ChangeSet| { &mut m.split },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "shardDelete",
                    |m: &ChangeSet| { &m.shard_delete },
                    |m: &mut ChangeSet| { &mut m.shard_delete },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence",
                    |m: &ChangeSet| { &m.sequence },
                    |m: &mut ChangeSet| { &mut m.sequence },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nextMemTableSize",
                    |m: &ChangeSet| { &m.next_mem_table_size },
                    |m: &mut ChangeSet| { &mut m.next_mem_table_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChangeSet>>(
                    "parent",
                    |m: &ChangeSet| { &m.parent },
                    |m: &mut ChangeSet| { &mut m.parent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeSet>(
                    "ChangeSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeSet {
        static mut instance: ::protobuf::lazy::Lazy<ChangeSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeSet,
        };
        unsafe {
            instance.get(ChangeSet::new)
        }
    }
}

impl ::protobuf::Clear for ChangeSet {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.shard_ver = 0;
        self.compaction.clear();
        self.flush.clear();
        self.snapshot.clear();
        self.stage = SplitStage::Initial;
        self.pre_split.clear();
        self.split_files.clear();
        self.split.clear();
        self.shard_delete = false;
        self.sequence = 0;
        self.next_mem_table_size = 0;
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ChangeSet {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.shard_id, "shard_id", buf);
        ::protobuf::PbPrint::fmt(&self.shard_ver, "shard_ver", buf);
        ::protobuf::PbPrint::fmt(&self.compaction, "compaction", buf);
        ::protobuf::PbPrint::fmt(&self.flush, "flush", buf);
        ::protobuf::PbPrint::fmt(&self.snapshot, "snapshot", buf);
        ::protobuf::PbPrint::fmt(&self.stage, "stage", buf);
        ::protobuf::PbPrint::fmt(&self.pre_split, "pre_split", buf);
        ::protobuf::PbPrint::fmt(&self.split_files, "split_files", buf);
        ::protobuf::PbPrint::fmt(&self.split, "split", buf);
        ::protobuf::PbPrint::fmt(&self.shard_delete, "shard_delete", buf);
        ::protobuf::PbPrint::fmt(&self.sequence, "sequence", buf);
        ::protobuf::PbPrint::fmt(&self.next_mem_table_size, "next_mem_table_size", buf);
        ::protobuf::PbPrint::fmt(&self.parent, "parent", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ChangeSet {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.shard_id, "shard_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.shard_ver, "shard_ver", &mut s);
        ::protobuf::PbPrint::fmt(&self.compaction, "compaction", &mut s);
        ::protobuf::PbPrint::fmt(&self.flush, "flush", &mut s);
        ::protobuf::PbPrint::fmt(&self.snapshot, "snapshot", &mut s);
        ::protobuf::PbPrint::fmt(&self.stage, "stage", &mut s);
        ::protobuf::PbPrint::fmt(&self.pre_split, "pre_split", &mut s);
        ::protobuf::PbPrint::fmt(&self.split_files, "split_files", &mut s);
        ::protobuf::PbPrint::fmt(&self.split, "split", &mut s);
        ::protobuf::PbPrint::fmt(&self.shard_delete, "shard_delete", &mut s);
        ::protobuf::PbPrint::fmt(&self.sequence, "sequence", &mut s);
        ::protobuf::PbPrint::fmt(&self.next_mem_table_size, "next_mem_table_size", &mut s);
        ::protobuf::PbPrint::fmt(&self.parent, "parent", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Compaction {
    // message fields
    pub cf: i32,
    pub level: u32,
    pub table_creates: ::protobuf::RepeatedField<TableCreate>,
    pub top_deletes: ::std::vec::Vec<u64>,
    pub bottom_deletes: ::std::vec::Vec<u64>,
    pub conflicted: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Compaction {
    fn default() -> &'a Compaction {
        <Compaction as ::protobuf::Message>::default_instance()
    }
}

impl Compaction {
    pub fn new() -> Compaction {
        ::std::default::Default::default()
    }

    // int32 cf = 1;


    pub fn get_cf(&self) -> i32 {
        self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: i32) {
        self.cf = v;
    }

    // uint32 level = 2;


    pub fn get_level(&self) -> u32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = v;
    }

    // repeated .enginepb.TableCreate tableCreates = 3;


    pub fn get_table_creates(&self) -> &[TableCreate] {
        &self.table_creates
    }
    pub fn clear_table_creates(&mut self) {
        self.table_creates.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_creates(&mut self, v: ::protobuf::RepeatedField<TableCreate>) {
        self.table_creates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_creates(&mut self) -> &mut ::protobuf::RepeatedField<TableCreate> {
        &mut self.table_creates
    }

    // Take field
    pub fn take_table_creates(&mut self) -> ::protobuf::RepeatedField<TableCreate> {
        ::std::mem::replace(&mut self.table_creates, ::protobuf::RepeatedField::new())
    }

    // repeated uint64 topDeletes = 4;


    pub fn get_top_deletes(&self) -> &[u64] {
        &self.top_deletes
    }
    pub fn clear_top_deletes(&mut self) {
        self.top_deletes.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_deletes(&mut self, v: ::std::vec::Vec<u64>) {
        self.top_deletes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_deletes(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.top_deletes
    }

    // Take field
    pub fn take_top_deletes(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.top_deletes, ::std::vec::Vec::new())
    }

    // repeated uint64 bottomDeletes = 5;


    pub fn get_bottom_deletes(&self) -> &[u64] {
        &self.bottom_deletes
    }
    pub fn clear_bottom_deletes(&mut self) {
        self.bottom_deletes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bottom_deletes(&mut self, v: ::std::vec::Vec<u64>) {
        self.bottom_deletes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bottom_deletes(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.bottom_deletes
    }

    // Take field
    pub fn take_bottom_deletes(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.bottom_deletes, ::std::vec::Vec::new())
    }

    // bool conflicted = 6;


    pub fn get_conflicted(&self) -> bool {
        self.conflicted
    }
    pub fn clear_conflicted(&mut self) {
        self.conflicted = false;
    }

    // Param is passed by value, moved
    pub fn set_conflicted(&mut self, v: bool) {
        self.conflicted = v;
    }
}

impl ::protobuf::Message for Compaction {
    fn is_initialized(&self) -> bool {
        for v in &self.table_creates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cf = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.table_creates)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.top_deletes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.bottom_deletes)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.conflicted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cf != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(2, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.table_creates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.top_deletes {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.bottom_deletes {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.conflicted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cf != 0 {
            os.write_int32(1, self.cf)?;
        }
        if self.level != 0 {
            os.write_uint32(2, self.level)?;
        }
        for v in &self.table_creates {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.top_deletes {
            os.write_uint64(4, *v)?;
        };
        for v in &self.bottom_deletes {
            os.write_uint64(5, *v)?;
        };
        if self.conflicted != false {
            os.write_bool(6, self.conflicted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Compaction {
        Compaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cf",
                    |m: &Compaction| { &m.cf },
                    |m: &mut Compaction| { &mut m.cf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    |m: &Compaction| { &m.level },
                    |m: &mut Compaction| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableCreate>>(
                    "tableCreates",
                    |m: &Compaction| { &m.table_creates },
                    |m: &mut Compaction| { &mut m.table_creates },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "topDeletes",
                    |m: &Compaction| { &m.top_deletes },
                    |m: &mut Compaction| { &mut m.top_deletes },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bottomDeletes",
                    |m: &Compaction| { &m.bottom_deletes },
                    |m: &mut Compaction| { &mut m.bottom_deletes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "conflicted",
                    |m: &Compaction| { &m.conflicted },
                    |m: &mut Compaction| { &mut m.conflicted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Compaction>(
                    "Compaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Compaction {
        static mut instance: ::protobuf::lazy::Lazy<Compaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Compaction,
        };
        unsafe {
            instance.get(Compaction::new)
        }
    }
}

impl ::protobuf::Clear for Compaction {
    fn clear(&mut self) {
        self.cf = 0;
        self.level = 0;
        self.table_creates.clear();
        self.top_deletes.clear();
        self.bottom_deletes.clear();
        self.conflicted = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Compaction {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.level, "level", buf);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", buf);
        ::protobuf::PbPrint::fmt(&self.top_deletes, "top_deletes", buf);
        ::protobuf::PbPrint::fmt(&self.bottom_deletes, "bottom_deletes", buf);
        ::protobuf::PbPrint::fmt(&self.conflicted, "conflicted", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Compaction {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.level, "level", &mut s);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", &mut s);
        ::protobuf::PbPrint::fmt(&self.top_deletes, "top_deletes", &mut s);
        ::protobuf::PbPrint::fmt(&self.bottom_deletes, "bottom_deletes", &mut s);
        ::protobuf::PbPrint::fmt(&self.conflicted, "conflicted", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Compaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Flush {
    // message fields
    pub l0_create: ::protobuf::SingularPtrField<L0Create>,
    pub properties: ::protobuf::SingularPtrField<Properties>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Flush {
    fn default() -> &'a Flush {
        <Flush as ::protobuf::Message>::default_instance()
    }
}

impl Flush {
    pub fn new() -> Flush {
        ::std::default::Default::default()
    }

    // .enginepb.L0Create l0Create = 1;


    pub fn get_l0_create(&self) -> &L0Create {
        self.l0_create.as_ref().unwrap_or_else(|| L0Create::default_instance())
    }
    pub fn clear_l0_create(&mut self) {
        self.l0_create.clear();
    }

    pub fn has_l0_create(&self) -> bool {
        self.l0_create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l0_create(&mut self, v: L0Create) {
        self.l0_create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_l0_create(&mut self) -> &mut L0Create {
        if self.l0_create.is_none() {
            self.l0_create.set_default();
        }
        self.l0_create.as_mut().unwrap()
    }

    // Take field
    pub fn take_l0_create(&mut self) -> L0Create {
        self.l0_create.take().unwrap_or_else(|| L0Create::new())
    }

    // .enginepb.Properties properties = 2;


    pub fn get_properties(&self) -> &Properties {
        self.properties.as_ref().unwrap_or_else(|| Properties::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: Properties) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut Properties {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> Properties {
        self.properties.take().unwrap_or_else(|| Properties::new())
    }
}

impl ::protobuf::Message for Flush {
    fn is_initialized(&self) -> bool {
        for v in &self.l0_create {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.l0_create)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.l0_create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.l0_create.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Flush {
        Flush::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<L0Create>>(
                    "l0Create",
                    |m: &Flush| { &m.l0_create },
                    |m: &mut Flush| { &mut m.l0_create },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Properties>>(
                    "properties",
                    |m: &Flush| { &m.properties },
                    |m: &mut Flush| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Flush>(
                    "Flush",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Flush {
        static mut instance: ::protobuf::lazy::Lazy<Flush> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Flush,
        };
        unsafe {
            instance.get(Flush::new)
        }
    }
}

impl ::protobuf::Clear for Flush {
    fn clear(&mut self) {
        self.l0_create.clear();
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Flush {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.l0_create, "l0_create", buf);
        ::protobuf::PbPrint::fmt(&self.properties, "properties", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Flush {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.l0_create, "l0_create", &mut s);
        ::protobuf::PbPrint::fmt(&self.properties, "properties", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Flush {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Snapshot {
    // message fields
    pub start: ::std::vec::Vec<u8>,
    pub end: ::std::vec::Vec<u8>,
    pub properties: ::protobuf::SingularPtrField<Properties>,
    pub split_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub l0_creates: ::protobuf::RepeatedField<L0Create>,
    pub table_creates: ::protobuf::RepeatedField<TableCreate>,
    pub base_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Snapshot {
    fn default() -> &'a Snapshot {
        <Snapshot as ::protobuf::Message>::default_instance()
    }
}

impl Snapshot {
    pub fn new() -> Snapshot {
        ::std::default::Default::default()
    }

    // bytes start = 1;


    pub fn get_start(&self) -> &[u8] {
        &self.start
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::std::vec::Vec<u8>) {
        self.start = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start
    }

    // Take field
    pub fn take_start(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start, ::std::vec::Vec::new())
    }

    // bytes end = 2;


    pub fn get_end(&self) -> &[u8] {
        &self.end
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end
    }

    // Take field
    pub fn take_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end, ::std::vec::Vec::new())
    }

    // .enginepb.Properties properties = 3;


    pub fn get_properties(&self) -> &Properties {
        self.properties.as_ref().unwrap_or_else(|| Properties::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: Properties) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut Properties {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> Properties {
        self.properties.take().unwrap_or_else(|| Properties::new())
    }

    // repeated bytes splitKeys = 4;


    pub fn get_split_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.split_keys
    }
    pub fn clear_split_keys(&mut self) {
        self.split_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.split_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_split_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.split_keys
    }

    // Take field
    pub fn take_split_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.split_keys, ::protobuf::RepeatedField::new())
    }

    // repeated .enginepb.L0Create l0Creates = 5;


    pub fn get_l0_creates(&self) -> &[L0Create] {
        &self.l0_creates
    }
    pub fn clear_l0_creates(&mut self) {
        self.l0_creates.clear();
    }

    // Param is passed by value, moved
    pub fn set_l0_creates(&mut self, v: ::protobuf::RepeatedField<L0Create>) {
        self.l0_creates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_l0_creates(&mut self) -> &mut ::protobuf::RepeatedField<L0Create> {
        &mut self.l0_creates
    }

    // Take field
    pub fn take_l0_creates(&mut self) -> ::protobuf::RepeatedField<L0Create> {
        ::std::mem::replace(&mut self.l0_creates, ::protobuf::RepeatedField::new())
    }

    // repeated .enginepb.TableCreate tableCreates = 6;


    pub fn get_table_creates(&self) -> &[TableCreate] {
        &self.table_creates
    }
    pub fn clear_table_creates(&mut self) {
        self.table_creates.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_creates(&mut self, v: ::protobuf::RepeatedField<TableCreate>) {
        self.table_creates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_creates(&mut self) -> &mut ::protobuf::RepeatedField<TableCreate> {
        &mut self.table_creates
    }

    // Take field
    pub fn take_table_creates(&mut self) -> ::protobuf::RepeatedField<TableCreate> {
        ::std::mem::replace(&mut self.table_creates, ::protobuf::RepeatedField::new())
    }

    // uint64 baseTS = 7;


    pub fn get_base_ts(&self) -> u64 {
        self.base_ts
    }
    pub fn clear_base_ts(&mut self) {
        self.base_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_ts(&mut self, v: u64) {
        self.base_ts = v;
    }
}

impl ::protobuf::Message for Snapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.l0_creates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_creates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.split_keys)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.l0_creates)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.table_creates)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.base_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.start);
        }
        if !self.end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.end);
        }
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.split_keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in &self.l0_creates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.table_creates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.base_ts != 0 {
            my_size += ::protobuf::rt::value_size(7, self.base_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.start.is_empty() {
            os.write_bytes(1, &self.start)?;
        }
        if !self.end.is_empty() {
            os.write_bytes(2, &self.end)?;
        }
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.split_keys {
            os.write_bytes(4, &v)?;
        };
        for v in &self.l0_creates {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.table_creates {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.base_ts != 0 {
            os.write_uint64(7, self.base_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Snapshot {
        Snapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "start",
                    |m: &Snapshot| { &m.start },
                    |m: &mut Snapshot| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "end",
                    |m: &Snapshot| { &m.end },
                    |m: &mut Snapshot| { &mut m.end },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Properties>>(
                    "properties",
                    |m: &Snapshot| { &m.properties },
                    |m: &mut Snapshot| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "splitKeys",
                    |m: &Snapshot| { &m.split_keys },
                    |m: &mut Snapshot| { &mut m.split_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<L0Create>>(
                    "l0Creates",
                    |m: &Snapshot| { &m.l0_creates },
                    |m: &mut Snapshot| { &mut m.l0_creates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableCreate>>(
                    "tableCreates",
                    |m: &Snapshot| { &m.table_creates },
                    |m: &mut Snapshot| { &mut m.table_creates },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "baseTS",
                    |m: &Snapshot| { &m.base_ts },
                    |m: &mut Snapshot| { &mut m.base_ts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Snapshot>(
                    "Snapshot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Snapshot {
        static mut instance: ::protobuf::lazy::Lazy<Snapshot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Snapshot,
        };
        unsafe {
            instance.get(Snapshot::new)
        }
    }
}

impl ::protobuf::Clear for Snapshot {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.properties.clear();
        self.split_keys.clear();
        self.l0_creates.clear();
        self.table_creates.clear();
        self.base_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Snapshot {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start, "start", buf);
        ::protobuf::PbPrint::fmt(&self.end, "end", buf);
        ::protobuf::PbPrint::fmt(&self.properties, "properties", buf);
        ::protobuf::PbPrint::fmt(&self.split_keys, "split_keys", buf);
        ::protobuf::PbPrint::fmt(&self.l0_creates, "l0_creates", buf);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", buf);
        ::protobuf::PbPrint::fmt(&self.base_ts, "base_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Snapshot {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start, "start", &mut s);
        ::protobuf::PbPrint::fmt(&self.end, "end", &mut s);
        ::protobuf::PbPrint::fmt(&self.properties, "properties", &mut s);
        ::protobuf::PbPrint::fmt(&self.split_keys, "split_keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.l0_creates, "l0_creates", &mut s);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", &mut s);
        ::protobuf::PbPrint::fmt(&self.base_ts, "base_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Snapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SplitFiles {
    // message fields
    pub l0_creates: ::protobuf::RepeatedField<L0Create>,
    pub table_creates: ::protobuf::RepeatedField<TableCreate>,
    pub table_deletes: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SplitFiles {
    fn default() -> &'a SplitFiles {
        <SplitFiles as ::protobuf::Message>::default_instance()
    }
}

impl SplitFiles {
    pub fn new() -> SplitFiles {
        ::std::default::Default::default()
    }

    // repeated .enginepb.L0Create l0Creates = 1;


    pub fn get_l0_creates(&self) -> &[L0Create] {
        &self.l0_creates
    }
    pub fn clear_l0_creates(&mut self) {
        self.l0_creates.clear();
    }

    // Param is passed by value, moved
    pub fn set_l0_creates(&mut self, v: ::protobuf::RepeatedField<L0Create>) {
        self.l0_creates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_l0_creates(&mut self) -> &mut ::protobuf::RepeatedField<L0Create> {
        &mut self.l0_creates
    }

    // Take field
    pub fn take_l0_creates(&mut self) -> ::protobuf::RepeatedField<L0Create> {
        ::std::mem::replace(&mut self.l0_creates, ::protobuf::RepeatedField::new())
    }

    // repeated .enginepb.TableCreate tableCreates = 2;


    pub fn get_table_creates(&self) -> &[TableCreate] {
        &self.table_creates
    }
    pub fn clear_table_creates(&mut self) {
        self.table_creates.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_creates(&mut self, v: ::protobuf::RepeatedField<TableCreate>) {
        self.table_creates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_creates(&mut self) -> &mut ::protobuf::RepeatedField<TableCreate> {
        &mut self.table_creates
    }

    // Take field
    pub fn take_table_creates(&mut self) -> ::protobuf::RepeatedField<TableCreate> {
        ::std::mem::replace(&mut self.table_creates, ::protobuf::RepeatedField::new())
    }

    // repeated uint64 tableDeletes = 3;


    pub fn get_table_deletes(&self) -> &[u64] {
        &self.table_deletes
    }
    pub fn clear_table_deletes(&mut self) {
        self.table_deletes.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_deletes(&mut self, v: ::std::vec::Vec<u64>) {
        self.table_deletes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_deletes(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.table_deletes
    }

    // Take field
    pub fn take_table_deletes(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.table_deletes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SplitFiles {
    fn is_initialized(&self) -> bool {
        for v in &self.l0_creates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_creates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.l0_creates)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.table_creates)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.table_deletes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.l0_creates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.table_creates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.table_deletes {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.l0_creates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.table_creates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.table_deletes {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SplitFiles {
        SplitFiles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<L0Create>>(
                    "l0Creates",
                    |m: &SplitFiles| { &m.l0_creates },
                    |m: &mut SplitFiles| { &mut m.l0_creates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableCreate>>(
                    "tableCreates",
                    |m: &SplitFiles| { &m.table_creates },
                    |m: &mut SplitFiles| { &mut m.table_creates },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tableDeletes",
                    |m: &SplitFiles| { &m.table_deletes },
                    |m: &mut SplitFiles| { &mut m.table_deletes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SplitFiles>(
                    "SplitFiles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SplitFiles {
        static mut instance: ::protobuf::lazy::Lazy<SplitFiles> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SplitFiles,
        };
        unsafe {
            instance.get(SplitFiles::new)
        }
    }
}

impl ::protobuf::Clear for SplitFiles {
    fn clear(&mut self) {
        self.l0_creates.clear();
        self.table_creates.clear();
        self.table_deletes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SplitFiles {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.l0_creates, "l0_creates", buf);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", buf);
        ::protobuf::PbPrint::fmt(&self.table_deletes, "table_deletes", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SplitFiles {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.l0_creates, "l0_creates", &mut s);
        ::protobuf::PbPrint::fmt(&self.table_creates, "table_creates", &mut s);
        ::protobuf::PbPrint::fmt(&self.table_deletes, "table_deletes", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitFiles {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct L0Create {
    // message fields
    pub id: u64,
    pub smallest: ::std::vec::Vec<u8>,
    pub biggest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a L0Create {
    fn default() -> &'a L0Create {
        <L0Create as ::protobuf::Message>::default_instance()
    }
}

impl L0Create {
    pub fn new() -> L0Create {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // bytes smallest = 2;


    pub fn get_smallest(&self) -> &[u8] {
        &self.smallest
    }
    pub fn clear_smallest(&mut self) {
        self.smallest.clear();
    }

    // Param is passed by value, moved
    pub fn set_smallest(&mut self, v: ::std::vec::Vec<u8>) {
        self.smallest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smallest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.smallest
    }

    // Take field
    pub fn take_smallest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.smallest, ::std::vec::Vec::new())
    }

    // bytes biggest = 3;


    pub fn get_biggest(&self) -> &[u8] {
        &self.biggest
    }
    pub fn clear_biggest(&mut self) {
        self.biggest.clear();
    }

    // Param is passed by value, moved
    pub fn set_biggest(&mut self, v: ::std::vec::Vec<u8>) {
        self.biggest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_biggest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.biggest
    }

    // Take field
    pub fn take_biggest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.biggest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for L0Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.smallest)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.biggest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.smallest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.smallest);
        }
        if !self.biggest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.biggest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if !self.smallest.is_empty() {
            os.write_bytes(2, &self.smallest)?;
        }
        if !self.biggest.is_empty() {
            os.write_bytes(3, &self.biggest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> L0Create {
        L0Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ID",
                    |m: &L0Create| { &m.id },
                    |m: &mut L0Create| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "smallest",
                    |m: &L0Create| { &m.smallest },
                    |m: &mut L0Create| { &mut m.smallest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "biggest",
                    |m: &L0Create| { &m.biggest },
                    |m: &mut L0Create| { &mut m.biggest },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<L0Create>(
                    "L0Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static L0Create {
        static mut instance: ::protobuf::lazy::Lazy<L0Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const L0Create,
        };
        unsafe {
            instance.get(L0Create::new)
        }
    }
}

impl ::protobuf::Clear for L0Create {
    fn clear(&mut self) {
        self.id = 0;
        self.smallest.clear();
        self.biggest.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for L0Create {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.id, "id", buf);
        ::protobuf::PbPrint::fmt(&self.smallest, "smallest", buf);
        ::protobuf::PbPrint::fmt(&self.biggest, "biggest", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for L0Create {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.id, "id", &mut s);
        ::protobuf::PbPrint::fmt(&self.smallest, "smallest", &mut s);
        ::protobuf::PbPrint::fmt(&self.biggest, "biggest", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for L0Create {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableCreate {
    // message fields
    pub id: u64,
    pub level: u32,
    pub cf: i32,
    pub smallest: ::std::vec::Vec<u8>,
    pub biggest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableCreate {
    fn default() -> &'a TableCreate {
        <TableCreate as ::protobuf::Message>::default_instance()
    }
}

impl TableCreate {
    pub fn new() -> TableCreate {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint32 level = 2;


    pub fn get_level(&self) -> u32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = v;
    }

    // int32 CF = 3;


    pub fn get_cf(&self) -> i32 {
        self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: i32) {
        self.cf = v;
    }

    // bytes smallest = 4;


    pub fn get_smallest(&self) -> &[u8] {
        &self.smallest
    }
    pub fn clear_smallest(&mut self) {
        self.smallest.clear();
    }

    // Param is passed by value, moved
    pub fn set_smallest(&mut self, v: ::std::vec::Vec<u8>) {
        self.smallest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smallest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.smallest
    }

    // Take field
    pub fn take_smallest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.smallest, ::std::vec::Vec::new())
    }

    // bytes biggest = 5;


    pub fn get_biggest(&self) -> &[u8] {
        &self.biggest
    }
    pub fn clear_biggest(&mut self) {
        self.biggest.clear();
    }

    // Param is passed by value, moved
    pub fn set_biggest(&mut self, v: ::std::vec::Vec<u8>) {
        self.biggest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_biggest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.biggest
    }

    // Take field
    pub fn take_biggest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.biggest, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TableCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cf = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.smallest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.biggest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(2, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cf, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.smallest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.smallest);
        }
        if !self.biggest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.biggest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if self.level != 0 {
            os.write_uint32(2, self.level)?;
        }
        if self.cf != 0 {
            os.write_int32(3, self.cf)?;
        }
        if !self.smallest.is_empty() {
            os.write_bytes(4, &self.smallest)?;
        }
        if !self.biggest.is_empty() {
            os.write_bytes(5, &self.biggest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableCreate {
        TableCreate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ID",
                    |m: &TableCreate| { &m.id },
                    |m: &mut TableCreate| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "level",
                    |m: &TableCreate| { &m.level },
                    |m: &mut TableCreate| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CF",
                    |m: &TableCreate| { &m.cf },
                    |m: &mut TableCreate| { &mut m.cf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "smallest",
                    |m: &TableCreate| { &m.smallest },
                    |m: &mut TableCreate| { &mut m.smallest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "biggest",
                    |m: &TableCreate| { &m.biggest },
                    |m: &mut TableCreate| { &mut m.biggest },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TableCreate>(
                    "TableCreate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TableCreate {
        static mut instance: ::protobuf::lazy::Lazy<TableCreate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TableCreate,
        };
        unsafe {
            instance.get(TableCreate::new)
        }
    }
}

impl ::protobuf::Clear for TableCreate {
    fn clear(&mut self) {
        self.id = 0;
        self.level = 0;
        self.cf = 0;
        self.smallest.clear();
        self.biggest.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for TableCreate {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.id, "id", buf);
        ::protobuf::PbPrint::fmt(&self.level, "level", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.smallest, "smallest", buf);
        ::protobuf::PbPrint::fmt(&self.biggest, "biggest", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for TableCreate {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.id, "id", &mut s);
        ::protobuf::PbPrint::fmt(&self.level, "level", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.smallest, "smallest", &mut s);
        ::protobuf::PbPrint::fmt(&self.biggest, "biggest", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableCreate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreSplit {
    // message fields
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreSplit {
    fn default() -> &'a PreSplit {
        <PreSplit as ::protobuf::Message>::default_instance()
    }
}

impl PreSplit {
    pub fn new() -> PreSplit {
        ::std::default::Default::default()
    }

    // repeated bytes Keys = 1;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PreSplit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreSplit {
        PreSplit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Keys",
                    |m: &PreSplit| { &m.keys },
                    |m: &mut PreSplit| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreSplit>(
                    "PreSplit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreSplit {
        static mut instance: ::protobuf::lazy::Lazy<PreSplit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreSplit,
        };
        unsafe {
            instance.get(PreSplit::new)
        }
    }
}

impl ::protobuf::Clear for PreSplit {
    fn clear(&mut self) {
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for PreSplit {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for PreSplit {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreSplit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Split {
    // message fields
    pub new_shards: ::protobuf::RepeatedField<Properties>,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Split {
    fn default() -> &'a Split {
        <Split as ::protobuf::Message>::default_instance()
    }
}

impl Split {
    pub fn new() -> Split {
        ::std::default::Default::default()
    }

    // repeated .enginepb.Properties newShards = 1;


    pub fn get_new_shards(&self) -> &[Properties] {
        &self.new_shards
    }
    pub fn clear_new_shards(&mut self) {
        self.new_shards.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_shards(&mut self, v: ::protobuf::RepeatedField<Properties>) {
        self.new_shards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_shards(&mut self) -> &mut ::protobuf::RepeatedField<Properties> {
        &mut self.new_shards
    }

    // Take field
    pub fn take_new_shards(&mut self) -> ::protobuf::RepeatedField<Properties> {
        ::std::mem::replace(&mut self.new_shards, ::protobuf::RepeatedField::new())
    }

    // repeated bytes Keys = 3;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Split {
    fn is_initialized(&self) -> bool {
        for v in &self.new_shards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_shards)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.new_shards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.new_shards {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.keys {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Split {
        Split::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Properties>>(
                    "newShards",
                    |m: &Split| { &m.new_shards },
                    |m: &mut Split| { &mut m.new_shards },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Keys",
                    |m: &Split| { &m.keys },
                    |m: &mut Split| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Split>(
                    "Split",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Split {
        static mut instance: ::protobuf::lazy::Lazy<Split> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Split,
        };
        unsafe {
            instance.get(Split::new)
        }
    }
}

impl ::protobuf::Clear for Split {
    fn clear(&mut self) {
        self.new_shards.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Split {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.new_shards, "new_shards", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Split {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.new_shards, "new_shards", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Split {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Properties {
    // message fields
    pub shard_id: u64,
    pub keys: ::protobuf::RepeatedField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Properties {
    fn default() -> &'a Properties {
        <Properties as ::protobuf::Message>::default_instance()
    }
}

impl Properties {
    pub fn new() -> Properties {
        ::std::default::Default::default()
    }

    // uint64 shardID = 1;


    pub fn get_shard_id(&self) -> u64 {
        self.shard_id
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: u64) {
        self.shard_id = v;
    }

    // repeated string keys = 2;


    pub fn get_keys(&self) -> &[::std::string::String] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // repeated bytes values = 3;


    pub fn get_values(&self) -> &[::std::vec::Vec<u8>] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Properties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shard_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shard_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shard_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.values {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shard_id != 0 {
            os.write_uint64(1, self.shard_id)?;
        }
        for v in &self.keys {
            os.write_string(2, &v)?;
        };
        for v in &self.values {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Properties {
        Properties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "shardID",
                    |m: &Properties| { &m.shard_id },
                    |m: &mut Properties| { &mut m.shard_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keys",
                    |m: &Properties| { &m.keys },
                    |m: &mut Properties| { &mut m.keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "values",
                    |m: &Properties| { &m.values },
                    |m: &mut Properties| { &mut m.values },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Properties>(
                    "Properties",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Properties {
        static mut instance: ::protobuf::lazy::Lazy<Properties> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Properties,
        };
        unsafe {
            instance.get(Properties::new)
        }
    }
}

impl ::protobuf::Clear for Properties {
    fn clear(&mut self) {
        self.shard_id = 0;
        self.keys.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Properties {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.shard_id, "shard_id", buf);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", buf);
        ::protobuf::PbPrint::fmt(&self.values, "values", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Properties {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.shard_id, "shard_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.keys, "keys", &mut s);
        ::protobuf::PbPrint::fmt(&self.values, "values", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Properties {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SplitStage {
    Initial = 0,
    PreSplit = 1,
    PreSplitFlushDone = 2,
    SplitFileDone = 3,
}

impl ::protobuf::ProtobufEnum for SplitStage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SplitStage> {
        match value {
            0 => ::std::option::Option::Some(SplitStage::Initial),
            1 => ::std::option::Option::Some(SplitStage::PreSplit),
            2 => ::std::option::Option::Some(SplitStage::PreSplitFlushDone),
            3 => ::std::option::Option::Some(SplitStage::SplitFileDone),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SplitStage] = &[
            SplitStage::Initial,
            SplitStage::PreSplit,
            SplitStage::PreSplitFlushDone,
            SplitStage::SplitFileDone,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SplitStage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SplitStage {
}

impl ::protobuf::PbPrint for SplitStage {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == SplitStage::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for SplitStage {
    fn default() -> Self {
        SplitStage::Initial
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitStage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fchangeset.proto\x12\x08enginepb\"\xb5\x03\n\tChangeSet\x12\x11\n\
    \x07shardID\x18\x01\x20\x01(\x04B\0\x12\x12\n\x08shardVer\x18\x02\x20\
    \x01(\x04B\0\x12*\n\ncompaction\x18\x04\x20\x01(\x0b2\x14.enginepb.Compa\
    ctionB\0\x12\x20\n\x05flush\x18\x05\x20\x01(\x0b2\x0f.enginepb.FlushB\0\
    \x12&\n\x08snapshot\x18\x06\x20\x01(\x0b2\x12.enginepb.SnapshotB\0\x12%\
    \n\x05stage\x18\x07\x20\x01(\x0e2\x14.enginepb.SplitStageB\0\x12&\n\x08p\
    reSplit\x18\x08\x20\x01(\x0b2\x12.enginepb.PreSplitB\0\x12*\n\nsplitFile\
    s\x18\t\x20\x01(\x0b2\x14.enginepb.SplitFilesB\0\x12\x20\n\x05split\x18\
    \n\x20\x01(\x0b2\x0f.enginepb.SplitB\0\x12\x15\n\x0bshardDelete\x18\x0b\
    \x20\x01(\x08B\0\x12\x12\n\x08sequence\x18\x0c\x20\x01(\x04B\0\x12\x1a\n\
    \x10nextMemTableSize\x18\r\x20\x01(\x03B\0\x12%\n\x06parent\x18\x0e\x20\
    \x01(\x0b2\x13.enginepb.ChangeSetB\0:\0\"\xa1\x01\n\nCompaction\x12\x0c\
    \n\x02cf\x18\x01\x20\x01(\x05B\0\x12\x0f\n\x05level\x18\x02\x20\x01(\rB\
    \0\x12-\n\x0ctableCreates\x18\x03\x20\x03(\x0b2\x15.enginepb.TableCreate\
    B\0\x12\x14\n\ntopDeletes\x18\x04\x20\x03(\x04B\0\x12\x17\n\rbottomDelet\
    es\x18\x05\x20\x03(\x04B\0\x12\x14\n\nconflicted\x18\x06\x20\x01(\x08B\0\
    :\0\"]\n\x05Flush\x12&\n\x08l0Create\x18\x01\x20\x01(\x0b2\x12.enginepb.\
    L0CreateB\0\x12*\n\nproperties\x18\x02\x20\x01(\x0b2\x14.enginepb.Proper\
    tiesB\0:\0\"\xd7\x01\n\x08Snapshot\x12\x0f\n\x05start\x18\x01\x20\x01(\
    \x0cB\0\x12\r\n\x03end\x18\x02\x20\x01(\x0cB\0\x12*\n\nproperties\x18\
    \x03\x20\x01(\x0b2\x14.enginepb.PropertiesB\0\x12\x13\n\tsplitKeys\x18\
    \x04\x20\x03(\x0cB\0\x12'\n\tl0Creates\x18\x05\x20\x03(\x0b2\x12.enginep\
    b.L0CreateB\0\x12-\n\x0ctableCreates\x18\x06\x20\x03(\x0b2\x15.enginepb.\
    TableCreateB\0\x12\x10\n\x06baseTS\x18\x07\x20\x01(\x04B\0:\0\"~\n\nSpli\
    tFiles\x12'\n\tl0Creates\x18\x01\x20\x03(\x0b2\x12.enginepb.L0CreateB\0\
    \x12-\n\x0ctableCreates\x18\x02\x20\x03(\x0b2\x15.enginepb.TableCreateB\
    \0\x12\x16\n\x0ctableDeletes\x18\x03\x20\x03(\x04B\0:\0\"A\n\x08L0Create\
    \x12\x0c\n\x02ID\x18\x01\x20\x01(\x04B\0\x12\x12\n\x08smallest\x18\x02\
    \x20\x01(\x0cB\0\x12\x11\n\x07biggest\x18\x03\x20\x01(\x0cB\0:\0\"c\n\
    \x0bTableCreate\x12\x0c\n\x02ID\x18\x01\x20\x01(\x04B\0\x12\x0f\n\x05lev\
    el\x18\x02\x20\x01(\rB\0\x12\x0c\n\x02CF\x18\x03\x20\x01(\x05B\0\x12\x12\
    \n\x08smallest\x18\x04\x20\x01(\x0cB\0\x12\x11\n\x07biggest\x18\x05\x20\
    \x01(\x0cB\0:\0\"\x1c\n\x08PreSplit\x12\x0e\n\x04Keys\x18\x01\x20\x03(\
    \x0cB\0:\0\"D\n\x05Split\x12)\n\tnewShards\x18\x01\x20\x03(\x0b2\x14.eng\
    inepb.PropertiesB\0\x12\x0e\n\x04Keys\x18\x03\x20\x03(\x0cB\0:\0\"C\n\nP\
    roperties\x12\x11\n\x07shardID\x18\x01\x20\x01(\x04B\0\x12\x0e\n\x04keys\
    \x18\x02\x20\x03(\tB\0\x12\x10\n\x06values\x18\x03\x20\x03(\x0cB\0:\0*Y\
    \n\nSplitStage\x12\x0b\n\x07INITIAL\x10\0\x12\r\n\tPRE_SPLIT\x10\x01\x12\
    \x18\n\x14PRE_SPLIT_FLUSH_DONE\x10\x02\x12\x13\n\x0fSPLIT_FILE_DONE\x10\
    \x03\x1a\0B\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
